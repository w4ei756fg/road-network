<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>bx = 100;
by = 100;
ex = 400;
ey = 400;
px = 300;
py = 100;

curve = makeBezierCurve(bx, by, ex, ey, px, py, 1);

/* 도로 모양
 * 
 * 0 직선
 * 1 곡선
 * 2 자유형
 */
modeRoadShape = 0;

/* 도로 툴 */
modeRoad = 0;

/* 도로 긋기 단계 */
stageRoad = 0;

/* 도로 긋기 좌표 */
for(var i = 0; i &lt; 3; i++) {
    mx[i] = 0;
    my[i] = 0;
    mid[i] = -1;
}

/* 노드, 엣지 색인 */
node = ds_list_create();
edge = ds_list_create();

/* 도로 긋기 데드존 */
deadzone = 10;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="53">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (modeRoad == 1) {
    switch(modeRoadShape) {
        case 0: // 직선
        mx[stageRoad] = mouse_x;
        my[stageRoad] = mouse_y;
        mid[stageRoad] = findNearest(mx[stageRoad], my[stageRoad], node);
        if(stageRoad = 1) {
            for(var i = 0; i &lt; 2; i++)
            if (mid[i] == -1 || point_distance(mid[i].x, mid[i].y, mx[i], my[i]) &gt; deadzone) { // 근접 노드가 없으면
                // 노드 생성
                mid[i] = addList(node, mx[i], my[i], CrossRoad);
            }
            var roadPreset = -1;
            //도로 생성
            //var newRoad = addRoad(mid[0], mid[1], (mx[0] + mx[1]) / 2, (my[0] + my[1]) / 2, roadPreset);
            var newRoad = addList(edge, mid[0].x, mid[0].y, Road);
            with(newRoad) {
                bid = other.mid[0];
                eid = other.mid[1];
                px = (other.mx[0] + other.mx[1]) / 2;
                py = (other.my[0] + other.my[1]) / 2;
            }
            stageRoad = 0;
        }
        else 
            stageRoad++;
        break;
        
        case 1: // 곡선
        mx[stageRoad] = mouse_x;
        my[stageRoad] = mouse_y;
        mid[stageRoad] = findNearest(mx[stageRoad], my[stageRoad], node);
        if(stageRoad = 2) {
            for(var i = 0; i &lt; 3; i += 2)
            if (mid[i] == -1 || point_distance(mid[i].x, mid[i].y, mx[i], my[i]) &gt; deadzone) { // 근접 노드가 없으면
                // 노드 생성
                mid[i] = addList(node, mx[i], my[i], CrossRoad);
            }
            var roadPreset = -1;
            //도로 생성
            //var newRoad = addRoad(mid[0], mid[1], (mx[0] + mx[1]) / 2, (my[0] + my[1]) / 2, roadPreset);
            var newRoad = addList(edge, mid[0].x, mid[0].y, Road);
            with(newRoad) {
                bid = other.mid[0];
                eid = other.mid[2];
                px = other.mx[1];
                py = other.my[1];
            }
            stageRoad = 0;
        }
        else 
            stageRoad++;
        break;
        case 2: // 컷
        mx[stageRoad] = mouse_x;
        my[stageRoad] = mouse_y;
        mid[stageRoad] = findNearestEdge(edge, mx[stageRoad], my[stageRoad]);
        show_debug_message(mid[stageRoad]);
        var mpi = findNearestPointInCurve(mid[stageRoad].curve, mx[stageRoad], my[stageRoad]);
        if (getDistancePointInCurve(mid[stageRoad].curve, mpi, mx[stageRoad], my[stageRoad]) &lt; deadzone) {
            cutRoad(mid[stageRoad], mpi);
        }
        
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="50">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>px = mouse_x;
py = mouse_y;
ds_list_destroy(curve);
curve = makeBezierCurve(bx, by, ex, ey, px, py, 1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
 * bezier curve test
draw_set_colour(c_red);
draw_circle(bx, by, 10, 1);
draw_text(bx, by, "x: " + string(bx));
draw_text(bx, by + 20, "y: " + string(by));

draw_set_colour(c_red);
draw_circle(ex, ey, 10, 1);
draw_text(ex, ey, "x: " + string(ex));
draw_text(ex, ey + 20, "y: " + string(ey));

draw_set_colour(c_purple);
draw_circle(px, py, 10, 1);
draw_text(px, py, "x: " + string(px));
draw_text(px, py + 20, "y: " + string(py));

draw_set_colour(c_green);
draw_curve(curve);
*/

draw_set_colour(c_black);
draw_text(0, 10, "modeRoadShape: " + string(modeRoadShape));
draw_text(0, 10 + 20, "modeRoad: " + string(modeRoad));
draw_text(0, 10 + 40, "stageRoad: " + string(stageRoad));

for(var i = 0; i &lt; 3; i++) {
    draw_text(0, 70 + 60*i, "mx[" + string(i) + "]: " + string(mx[i]));
    draw_text(0, 90 + 60*i, "my[" + string(i) + "]: " + string(my[i]));
    draw_text(0, 110 + 60*i, "mid[" + string(i) + "]: " + string(mid[i]));
}

//road tool
if (modeRoad == 1) {
    draw_set_color(c_fuchsia);
    var near = findNearest(mouse_x, mouse_y, node);
    switch(modeRoadShape) {
        case 0: // 직선
        if (stageRoad == 1) {
            if (point_distance(mid[0].x, mid[0].y, mx[0], my[0]) &gt; deadzone) {
                //preview circle
                draw_circle(mx[0], my[0], 10, 1);
                //preview line
                if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone)
                    draw_line(mx[0], my[0], mouse_x, mouse_y);
                else
                    draw_line(mx[0], my[0], near.x, near.y);
                
            } else {
                //preview circle
                draw_circle(mid[0].x, mid[0].y, 10, 1);
                //preview line
                if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone)
                    draw_line(mid[0].x, mid[0].x, mouse_x, mouse_y);
                else
                    draw_line(mid[0].x, mid[0].y, near.x, near.y);
            }
        }
        //current
        if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone)
            draw_circle(mouse_x, mouse_y, 10, 1);
        else
            draw_circle(near.x, near.y, 10, 1);
        break;
        
        case 1:
        for(var i = 0; i &lt; stageRoad; i++) {
            if (i == 1 || point_distance(mid[i].x, mid[i].y, mx[i], my[i]) &gt; deadzone) {
                //preview circle
                draw_circle(mx[i], my[i], 10, 1);
                //preview line
                if(stageRoad == 2 &amp;&amp; i == 0) {
                    if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone) {
                        var cur = makeBezierCurve(mx[i], my[i], mouse_x, mouse_y, mx[1], my[1], 1);
                        draw_curve(cur);
                        ds_list_destroy(cur);
                    } else {
                        var cur = makeBezierCurve(mx[i], my[i], near.x, near.y, mx[1], my[1], 1);
                        draw_curve(cur);
                        ds_list_destroy(cur);
                    }
                } else if (stageRoad == 1) {
                    if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone)
                        draw_line(mx[i], my[i], mouse_x, mouse_y);
                    else
                        draw_line(mx[i], my[i], near.x, near.y);
                }
            } else {
                //preview circle
                draw_circle(mid[i].x, mid[i].y, 10, 1);
                //preview line
                if(stageRoad == 2 &amp;&amp; i == 0) {
                    if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone) {
                        var cur = makeBezierCurve(mid[i].x, mid[i].y, mouse_x, mouse_y, mx[1], my[1], 1);
                        draw_curve(cur);
                        ds_list_destroy(cur);
                    } else {
                        var cur = makeBezierCurve(mid[i].x, mid[i].y, near.x, near.y, mx[1], my[1], 1);
                        draw_curve(cur);
                        ds_list_destroy(cur);
                    }
                } else if (stageRoad == 1) {
                    if (near == -1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone)
                        draw_line(mid[i].x, mid[i].y, mouse_x, mouse_y);
                    else
                        draw_line(mid[i].x, mid[i].y, near.x, near.y);
                }
            }
        }
        //current
        if (near == -1 || i == 1 || point_distance(near.x, near.y, mouse_x, mouse_y) &gt; deadzone) 
            draw_circle(mouse_x, mouse_y, 10, 1);
        else
            draw_circle(near.x, near.y, 10, 1);
        break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="84">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>modeRoadShape = (modeRoadShape + 1) % 3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>modeRoad = !modeRoad;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
